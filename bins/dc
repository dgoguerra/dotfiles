#!/usr/bin/env bash

# Wrapper of `docker-compose` with some aliases to common commands.
#
# Requires js-yaml and jq to be installed:
#
#   brew install jq
#   npm install -g js-yaml
#

# Get a value from the current dir's docker-compose.yml
get-yaml() {
    js-yaml ./docker-compose.yml | jq "$1" -r
}

# App and DB service names
APP_SERVICE=app
DB_SERVICE=mysql

CMD="$1"
ARGS="${@:2}"

case "$CMD" in
mysql)
    DB=$(get-yaml .services.mysql.environment.MYSQL_DATABASE)
    USER=$(get-yaml .services.mysql.environment.MYSQL_USER)
    PASS=$(get-yaml .services.mysql.environment.MYSQL_PASSWORD)

    # Open mysql in existing db container
    docker-compose exec -T $DB_SERVICE mysql -u$USER -p$PASS $DB $ARGS
    ;;
dump)
    DB=$(get-yaml .services.mysql.environment.MYSQL_DATABASE)
    USER=$(get-yaml .services.mysql.environment.MYSQL_USER)
    PASS=$(get-yaml .services.mysql.environment.MYSQL_PASSWORD)
    FILE="${DB}_local_$(date +"%Y%m%d-%H%M").sql"

    # Dump mysql database, showing progress with `pv`
    docker-compose exec -T $DB_SERVICE mysqldump \
        -u$USER -p$PASS $DB $ARGS | pv > "$FILE"

    echo "$(pwd)/$FILE"
    ;;
test)
    # Run tests in existing app container.

    # If the project has a 'composer.json' file, assume its
    # a PHP project and the tests are run with phpunit.
    # If not, run "npm run test".
    if [[ -f composer.json ]]; then
        TEST_CMD="vendor/bin/phpunit"
    else
        TEST_CMD="npm run test"
    fi

    docker-compose exec $APP_SERVICE sh -c "$TEST_CMD $ARGS"
    ;;
npm)
    # Run npm in existing app container
    docker-compose exec $APP_SERVICE sh -c "npm $ARGS"
    ;;
sh)
    # Open shell or run a command in existing app container
    if [[ "$ARGS" == "" ]]; then
        docker-compose exec $APP_SERVICE sh
    else
        docker-compose exec $APP_SERVICE sh -c "$ARGS"
    fi
    ;;
*)
    # Pass any arguments to docker-compose
    docker-compose "$@"
    ;;
esac
